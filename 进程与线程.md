# 第二章 进程与线程
## 2.1 进程
### **什么是进程(process)**
 	进程是对正在运行程序的一个抽象，是操作系统核心的概念。每个进程运行时都相当于独占一个cpu，因为每个进程都有自己独立的地址空间， 包括程序计数器， 寄存器和变量的当前值
### **并发**
 	伪并发：一段时间内有多个工作同时进行。
 	并发(并行)：一个时间点上有多个工作同时进行。
 	伪并发的实现机制：短时间内在各个进程之间来回切换，实现并发。实际每一个给定
 	的瞬间只有一个进程在cpu上运行

<img src="C:\Users\huang\Pictures\操作系统\进程模型.png" alt="进程模型" style="zoom: 80%;" />

## 2.1.1 进程创建
### **促使进程创建的原因**
 	1. 系统初始化
 	2. 正在运行的程序执行了创建进程的系统调用
 	3. 用户请求创建一个新进程
 	4. 一个批处理作业的初始化

### **守护进程**
 	为相应某些服务请求，在后台等待被被唤醒并处理相应请求的进程。
### **不同操作系统下创建进程的方式**
 	1. unix
 		①、fork()一个父进程
 		②、在fork之后创建一个父进程的副本，父子进程除了id和地址空间不一样，会有
 		相同的内存映像，环境字符串和打开文件。
 		③、fork() == 0 代表子进程，此时运行execv(function, arg1...)可以将
 		子进程内存映像更改为新程序function.
 	2. windows
 		①、CreateProcess():既处理进程创建也负责把正确的程序装入新进程。该调用
 		有10个参数，包括执行的程序，输入给该程序的命令行参数，各种安全属性，有关
 		打开的文件是否继承的控制位，优先级信息，该进程所需要创建的窗口规格以及指
 		向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。
## 2.1.2 进程的终止
### 终止条件
 	1. 正常退出(自愿)
 	进程完成工作, 执行系统调用Exit()
 	2. 出错退出(自愿)
 	发出的错误，不会影响进程功能本身。非致命
 	3. 严重错误(非自愿): 
 	执行了非法的指令导致致命
 	4. 被其他进程杀死(非自愿)： 
 	其他kill()
### 系统调用
 	1. unix
 	创建进程： fork()+execv()
 	退出进程： Exit()
 	杀死进程： kill()
 	2. window
 	创建进程：CreateProcess() 
 	退出进程：ExitProcess()
 	杀死进程：TerminateProcess()
 ## 2.1.3 进程的层次
 	在某些操作系统中，当进程创建了另外一个进程后，父进程与子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。
 	1. unix
 	在unix操作系统中，进程和它的所有子进程以及后裔共同组成一个进程组。在unix中，进程不能剥夺子进程继承的“继承权”。
 	2. windows
 	在windows操作系统中没有进程层次的概念，所有的进程地位都是相同的。唯有类似进程层次的概念是在：创建进程的时候，父进程得到一个句柄，该句柄可以用来控制子进程。当父进程把句柄传送给其他进程后进程的层次状态便会消失。

## 2.1.4 进程的状态
 	每个进程都是独立的实体，有自己的程序计数器和内部状态，但是进程之间需要相互作用。
### 等待状态模型
 	在这种模型下有三种进程状态
 	1. 运行态(该时刻实际占用cpu)
 	2. 就绪态(可运行，cpu被其他进程占用，而处于等待状态)
 	3. 阻塞态(除非某种外部时间发生，否则进程不能运行)
       ![进程3状态](C:\Users\huang\Pictures\操作系统\进程3状态.png)
 	三种状态之间有四种可能的转换关系：
 	- 运行态->阻塞态：当前运行的进程，需要等待外部时间的发生无法运行下去
 	- 运行态->就绪态：当前运行的进程时间片用完，或被抢占。由调度程序决定
 	- 就绪态->运行态：cpu空闲，当前进程满足要求，由就绪状态的进程可以进入运行态
 	- 阻塞态->就绪态：当前进程有满足条件的外部事件发生，可以进入就绪态
### 挂起状态模型
 	在这种模型下有五种进程状态
 	1. 运行态(该时刻实际占用cpu)
 	2. 就绪态(可运行，cpu被其他进程占用，而处于等待状态)
 	3. 阻塞态(除非某种外部时间发生，否则进程不能运行)
 	4. 挂起就绪态
 	5. 挂起阻塞态
### 进程调度
 	基于进程的操作系统中最底层的是中断和调度处理，在该层之上是顺序进程。
 	![进程调度](C:\Users\huang\Pictures\操作系统\进程调度.png)
## 进程的实现
### 中断发生后操作系统最底层的工作步骤
 	1. 硬件压入堆栈程序计数器等。
 	2. 硬件从中断向量装入新的程序计数器
 	3. 汇编语言过程保存寄存器值
 	4. 汇编语言过程设置新的堆栈
 	5. c中断服务例程运行（典型的读和缓冲输入）
 	6. 调度程序决定下一个将要运行的进程
 	7. c过程返回至汇编代码
 	8. 汇编语言过程开始运行新的当前进程
 	一个进程在执行的过程中可能会被多次中断，但每次中断后，被中断的进程必须都返回到与中断发生前完全相同的状态。
## 多道程序设计模型
### CPU利用率：
 	cpu利用率 = 1-p^n (p: 进程处于等待的概率， n : 进程数)
![多道程序设计模型](C:\Users\huang\Pictures\操作系统\多道程序设计模型.png)

 		